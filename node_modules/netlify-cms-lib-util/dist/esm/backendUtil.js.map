{"version":3,"sources":["../../src/backendUtil.js"],"names":["filterByPropExtension","extension","propName","arr","filter","el","catchFormatErrors","format","formatter","res","err","Error","message","responseFormatters","json","contentType","headers","get","startsWith","text","blob","mapEntries","parseResponse","expectingOk","ok","status","body","responseParser","options"],"mappings":";;;;;;;;;AACA;;AACA;;;;;;;;;;;;AAEO,MAAMA,qBAAqB,GAAG,CAACC,SAAD,EAAYC,QAAZ,KAAyBC,GAAG,IAC/DA,GAAG,CAACC,MAAJ,CAAWC,EAAE,IAAI,yBAAc,mBAAIA,EAAJ,EAAQH,QAAR,CAAd,MAAqCD,SAAtD,CADK;;;;AAGP,MAAMK,iBAAiB,GAAG,CAACC,MAAD,EAASC,SAAT,KAAuBC,GAAG,IAAI;AACtD,MAAI;AACF,WAAOD,SAAS,CAACC,GAAD,CAAhB;AACD,GAFD,CAEE,OAAOC,GAAP,EAAY;AACZ,UAAM,IAAIC,KAAJ,CACH,uDAAsDJ,MAAO,MAAKG,GAAG,CAACE,OAAQ,EAD3E,CAAN;AAGD;AACF,CARD;;AAUA,MAAMC,kBAAkB,GAAG,uBAAO;AAChCC,EAAAA,IAAI,EAAE,MAAML,GAAN,IAAa;AACjB,UAAMM,WAAW,GAAGN,GAAG,CAACO,OAAJ,CAAYC,GAAZ,CAAgB,cAAhB,CAApB;;AACA,QAAI,CAACF,WAAW,CAACG,UAAZ,CAAuB,kBAAvB,CAAD,IAA+C,CAACH,WAAW,CAACG,UAAZ,CAAuB,WAAvB,CAApD,EAAyF;AACvF,YAAM,IAAIP,KAAJ,CAAW,GAAEI,WAAY,mCAAzB,CAAN;AACD;;AACD,WAAON,GAAG,CAACK,IAAJ,EAAP;AACD,GAP+B;AAQhCK,EAAAA,IAAI,EAAE,MAAMV,GAAN,IAAaA,GAAG,CAACU,IAAJ,EARa;AAShCC,EAAAA,IAAI,EAAE,MAAMX,GAAN,IAAaA,GAAG,CAACW,IAAJ;AATa,CAAP,EAUxBC,UAVwB,CAUb;AAAA;AAAA,MAAEd,MAAF;AAAA,MAAUC,SAAV;;AAAA,SAAyB,CAACD,MAAD,EAASD,iBAAiB,CAACC,MAAD,EAASC,SAAT,CAA1B,CAAzB;AAAA,CAVa,CAA3B;;AAYO,MAAMc,aAAa,GAAG,eAAhBA,aAAgB,CAAOb,GAAP,EAA6D;AAAA,kFAAP,EAAO;AAAA,gCAA/Cc,WAA+C;AAAA,MAA/CA,WAA+C,kCAAjC,IAAiC;AAAA,2BAA3BhB,MAA2B;AAAA,MAA3BA,MAA2B,6BAAlB,MAAkB;;AACxF,MAAIgB,WAAW,IAAI,CAACd,GAAG,CAACe,EAAxB,EAA4B;AAC1B,UAAM,IAAIb,KAAJ,CAAW,0DAAyDF,GAAG,CAACgB,MAAO,GAA/E,CAAN;AACD;;AACD,QAAMjB,SAAS,GAAGK,kBAAkB,CAACI,GAAnB,CAAuBV,MAAvB,EAA+B,KAA/B,CAAlB;;AACA,MAAI,CAACC,SAAL,EAAgB;AACd,UAAM,IAAIG,KAAJ,CAAW,GAAEJ,MAAO,sCAApB,CAAN;AACD;;AACD,QAAMmB,IAAI,GAAG,MAAMlB,SAAS,CAACC,GAAD,CAA5B;AACA,SAAOiB,IAAP;AACD,CAVM;;;;AAYA,MAAMC,cAAc,GAAGC,OAAO,IAAInB,GAAG,IAAIa,aAAa,CAACb,GAAD,EAAMmB,OAAN,CAAtD","sourcesContent":["import { get } from 'lodash';\nimport { fromJS } from 'immutable';\nimport { fileExtension } from './path';\n\nexport const filterByPropExtension = (extension, propName) => arr =>\n  arr.filter(el => fileExtension(get(el, propName)) === extension);\n\nconst catchFormatErrors = (format, formatter) => res => {\n  try {\n    return formatter(res);\n  } catch (err) {\n    throw new Error(\n      `Response cannot be parsed into the expected format (${format}): ${err.message}`,\n    );\n  }\n};\n\nconst responseFormatters = fromJS({\n  json: async res => {\n    const contentType = res.headers.get('Content-Type');\n    if (!contentType.startsWith('application/json') && !contentType.startsWith('text/json')) {\n      throw new Error(`${contentType} is not a valid JSON Content-Type`);\n    }\n    return res.json();\n  },\n  text: async res => res.text(),\n  blob: async res => res.blob(),\n}).mapEntries(([format, formatter]) => [format, catchFormatErrors(format, formatter)]);\n\nexport const parseResponse = async (res, { expectingOk = true, format = 'text' } = {}) => {\n  if (expectingOk && !res.ok) {\n    throw new Error(`Expected an ok response, but received an error status: ${res.status}.`);\n  }\n  const formatter = responseFormatters.get(format, false);\n  if (!formatter) {\n    throw new Error(`${format} is not a supported response format.`);\n  }\n  const body = await formatter(res);\n  return body;\n};\n\nexport const responseParser = options => res => parseResponse(res, options);\n"],"file":"backendUtil.js"}