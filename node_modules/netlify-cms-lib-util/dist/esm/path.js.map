{"version":3,"sources":["../../src/path.js"],"names":["absolutePath","RegExp","normalizePath","path","replace","resolvePath","basePath","test","indexOf","basename","p","ext","sections","split","lastPart","length","lastPartExt","substr","fileExtensionWithSeparator","pop","i","lastIndexOf","fileExtension"],"mappings":"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","sourcesContent":["const absolutePath = new RegExp('^(?:[a-z]+:)?//', 'i');\nconst normalizePath = path => path.replace(/[\\\\/]+/g, '/');\n\nexport function resolvePath(path, basePath) {\n  // No path provided, skip\n  if (!path) return null;\n\n  // It's an absolute path.\n  if (absolutePath.test(path)) return path;\n\n  if (path.indexOf('/') === -1) {\n    // It's a single file name, no directories. Prepend public folder\n    return normalizePath(`/${basePath}/${path}`);\n  }\n\n  // It's a relative path. Prepend a forward slash.\n  return normalizePath(`/${path}`);\n}\n\n/**\n * Return the last portion of a path. Similar to the Unix basename command.\n * @example Usage example\n *   path.basename('/foo/bar/baz/asdf/quux.html')\n *   // returns\n *   'quux.html'\n *\n *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')\n *   // returns\n *   'quux'\n */\nexport function basename(p, ext = '') {\n  // Special case: Normalize will modify this to '.'\n  if (p === '') {\n    return p;\n  }\n  // Normalize the string first to remove any weirdness.\n  p = normalizePath(p);\n  // Get the last part of the string.\n  const sections = p.split('/');\n  const lastPart = sections[sections.length - 1];\n  // Special case: If it's empty, then we have a string like so: foo/\n  // Meaning, 'foo' is guaranteed to be a directory.\n  if (lastPart === '' && sections.length > 1) {\n    return sections[sections.length - 2];\n  }\n  // Remove the extension, if need be.\n  if (ext.length > 0) {\n    const lastPartExt = lastPart.substr(lastPart.length - ext.length);\n    if (lastPartExt === ext) {\n      return lastPart.substr(0, lastPart.length - ext.length);\n    }\n  }\n  return lastPart;\n}\n\n/**\n * Return the extension of the path, from the last '.' to end of string in the\n * last portion of the path. If there is no '.' in the last portion of the path\n * or the first character of it is '.', then it returns an empty string.\n * @example Usage example\n *   path.fileExtensionWithSeparator('index.html')\n *   // returns\n *   '.html'\n */\nexport function fileExtensionWithSeparator(p) {\n  p = normalizePath(p);\n  const sections = p.split('/');\n  p = sections.pop();\n  // Special case: foo/file.ext/ should return '.ext'\n  if (p === '' && sections.length > 0) {\n    p = sections.pop();\n  }\n  if (p === '..') {\n    return '';\n  }\n  const i = p.lastIndexOf('.');\n  if (i === -1 || i === 0) {\n    return '';\n  }\n  return p.substr(i);\n}\n\n/**\n * Return the extension of the path, from after the last '.' to end of string in the\n * last portion of the path. If there is no '.' in the last portion of the path\n * or the first character of it is '.', then it returns an empty string.\n * @example Usage example\n *   path.fileExtension('index.html')\n *   // returns\n *   'html'\n */\nexport function fileExtension(p) {\n  const ext = fileExtensionWithSeparator(p);\n  return ext === '' ? ext : ext.substr(1);\n}\n"],"file":"path.js"}