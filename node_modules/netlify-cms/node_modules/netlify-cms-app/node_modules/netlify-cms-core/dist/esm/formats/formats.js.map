{"version":3,"sources":["../../../src/formats/formats.js"],"names":["frontmatterFormats","formatExtensions","yml","yaml","toml","json","frontmatter","extensionFormatters","yamlFormatter","tomlFormatter","jsonFormatter","md","FrontmatterInfer","markdown","html","formatByName","name","customDelimiter","resolveFormat","collectionOrEntity","entry","frontmatter_delimiter","get","List","isList","toArray","formatSpecification","filePath","path","fileExtension","split","pop","extension"],"mappings":";;;;;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;;;AAEO,MAAMA,kBAAkB,GAAG,CAAC,kBAAD,EAAqB,kBAArB,EAAyC,kBAAzC,CAA3B;;AAEA,MAAMC,gBAAgB,GAAG;AAC9BC,EAAAA,GAAG,EAAE,KADyB;AAE9BC,EAAAA,IAAI,EAAE,KAFwB;AAG9BC,EAAAA,IAAI,EAAE,MAHwB;AAI9BC,EAAAA,IAAI,EAAE,MAJwB;AAK9BC,EAAAA,WAAW,EAAE,IALiB;AAM9B,sBAAoB,IANU;AAO9B,sBAAoB,IAPU;AAQ9B,sBAAoB;AARU,CAAzB;;AAWA,MAAMC,mBAAmB,GAAG;AACjCL,EAAAA,GAAG,EAAEM,aAD4B;AAEjCL,EAAAA,IAAI,EAAEK,aAF2B;AAGjCJ,EAAAA,IAAI,EAAEK,aAH2B;AAIjCJ,EAAAA,IAAI,EAAEK,aAJ2B;AAKjCC,EAAAA,EAAE,EAAEC,6BAL6B;AAMjCC,EAAAA,QAAQ,EAAED,6BANuB;AAOjCE,EAAAA,IAAI,EAAEF;AAP2B,CAA5B;;;AAUP,MAAMG,YAAY,GAAG,CAACC,IAAD,EAAOC,eAAP,KAClB;AACCf,EAAAA,GAAG,EAAEM,aADN;AAECL,EAAAA,IAAI,EAAEK,aAFP;AAGCJ,EAAAA,IAAI,EAAEK,aAHP;AAICJ,EAAAA,IAAI,EAAEK,aAJP;AAKCJ,EAAAA,WAAW,EAAEM,6BALd;AAMC,sBAAoB,kCAAgBK,eAAhB,CANrB;AAOC,sBAAoB,kCAAgBA,eAAhB,CAPrB;AAQC,sBAAoB,kCAAgBA,eAAhB;AARrB,GASCD,IATD,CADH;;AAYO,SAASE,aAAT,CAAuBC,kBAAvB,EAA2CC,KAA3C,EAAkD;AACvD;AACA,QAAMC,qBAAqB,GAAGF,kBAAkB,CAACG,GAAnB,CAAuB,uBAAvB,CAA9B;AACA,QAAML,eAAe,GAAGM,gBAAKC,MAAL,CAAYH,qBAAZ,IACpBA,qBAAqB,CAACI,OAAtB,EADoB,GAEpBJ,qBAFJ,CAHuD,CAOvD;;AACA,QAAMK,mBAAmB,GAAGP,kBAAkB,CAACG,GAAnB,CAAuB,QAAvB,CAA5B;;AACA,MAAII,mBAAJ,EAAyB;AACvB,WAAOX,YAAY,CAACW,mBAAD,EAAsBT,eAAtB,CAAnB;AACD,GAXsD,CAavD;;;AACA,QAAMU,QAAQ,GAAGP,KAAK,IAAIA,KAAK,CAACQ,IAAhC;;AACA,MAAID,QAAJ,EAAc;AACZ,UAAME,aAAa,GAAGF,QAAQ,CAACG,KAAT,CAAe,GAAf,EAAoBC,GAApB,EAAtB;AACA,WAAO,mBAAIxB,mBAAJ,EAAyBsB,aAAzB,CAAP;AACD,GAlBsD,CAoBvD;AACA;;;AACA,QAAMG,SAAS,GAAGb,kBAAkB,CAACG,GAAnB,CAAuB,WAAvB,CAAlB;;AACA,MAAIU,SAAJ,EAAe;AACb,WAAO,mBAAIzB,mBAAJ,EAAyByB,SAAzB,CAAP;AACD,GAzBsD,CA2BvD;;;AACA,SAAOjB,YAAY,CAAC,aAAD,EAAgBE,eAAhB,CAAnB;AACD","sourcesContent":["import { List } from 'immutable';\nimport { get } from 'lodash';\nimport yamlFormatter from './yaml';\nimport tomlFormatter from './toml';\nimport jsonFormatter from './json';\nimport { FrontmatterInfer, frontmatterJSON, frontmatterTOML, frontmatterYAML } from './frontmatter';\n\nexport const frontmatterFormats = ['yaml-frontmatter', 'toml-frontmatter', 'json-frontmatter'];\n\nexport const formatExtensions = {\n  yml: 'yml',\n  yaml: 'yml',\n  toml: 'toml',\n  json: 'json',\n  frontmatter: 'md',\n  'json-frontmatter': 'md',\n  'toml-frontmatter': 'md',\n  'yaml-frontmatter': 'md',\n};\n\nexport const extensionFormatters = {\n  yml: yamlFormatter,\n  yaml: yamlFormatter,\n  toml: tomlFormatter,\n  json: jsonFormatter,\n  md: FrontmatterInfer,\n  markdown: FrontmatterInfer,\n  html: FrontmatterInfer,\n};\n\nconst formatByName = (name, customDelimiter) =>\n  ({\n    yml: yamlFormatter,\n    yaml: yamlFormatter,\n    toml: tomlFormatter,\n    json: jsonFormatter,\n    frontmatter: FrontmatterInfer,\n    'json-frontmatter': frontmatterJSON(customDelimiter),\n    'toml-frontmatter': frontmatterTOML(customDelimiter),\n    'yaml-frontmatter': frontmatterYAML(customDelimiter),\n  }[name]);\n\nexport function resolveFormat(collectionOrEntity, entry) {\n  // Check for custom delimiter\n  const frontmatter_delimiter = collectionOrEntity.get('frontmatter_delimiter');\n  const customDelimiter = List.isList(frontmatter_delimiter)\n    ? frontmatter_delimiter.toArray()\n    : frontmatter_delimiter;\n\n  // If the format is specified in the collection, use that format.\n  const formatSpecification = collectionOrEntity.get('format');\n  if (formatSpecification) {\n    return formatByName(formatSpecification, customDelimiter);\n  }\n\n  // If a file already exists, infer the format from its file extension.\n  const filePath = entry && entry.path;\n  if (filePath) {\n    const fileExtension = filePath.split('.').pop();\n    return get(extensionFormatters, fileExtension);\n  }\n\n  // If creating a new file, and an `extension` is specified in the\n  //   collection config, infer the format from that extension.\n  const extension = collectionOrEntity.get('extension');\n  if (extension) {\n    return get(extensionFormatters, extension);\n  }\n\n  // If no format is specified and it cannot be inferred, return the default.\n  return formatByName('frontmatter', customDelimiter);\n}\n"],"file":"formats.js"}