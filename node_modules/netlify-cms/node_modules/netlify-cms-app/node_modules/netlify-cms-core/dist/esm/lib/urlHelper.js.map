{"version":3,"sources":["../../../src/lib/urlHelper.js"],"names":["getUrl","urlString","direct","getCollectionUrl","collectionName","getNewEntryUrl","addParams","params","parsedUrl","url","parse","query","format","stripProtocol","protocolEndIndex","indexOf","slice","uriChars","ucsChars","validURIChar","char","test","validIRIChar","sanitizeURI","str","replacement","encoding","Error","validChar","Array","from","every","map","join","sanitizeSlug","options","get","stripDiacritics","sanitizedSlug","diacritics","remove","sanitizeFilename","doubleReplacement","RegExp","trailingReplacment","leadingReplacment","normalizedSlug","replace"],"mappings":"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","sourcesContent":["import url from 'url';\nimport diacritics from 'diacritics';\nimport sanitizeFilename from 'sanitize-filename';\nimport { isString, escapeRegExp, flow, partialRight } from 'lodash';\nimport { Map } from 'immutable';\n\nfunction getUrl(urlString, direct) {\n  return `${direct ? '/#' : ''}${urlString}`;\n}\n\nexport function getCollectionUrl(collectionName, direct) {\n  return getUrl(`/collections/${collectionName}`, direct);\n}\n\nexport function getNewEntryUrl(collectionName, direct) {\n  return getUrl(`/collections/${collectionName}/new`, direct);\n}\n\nexport function addParams(urlString, params) {\n  const parsedUrl = url.parse(urlString, true);\n  parsedUrl.query = { ...parsedUrl.query, ...params };\n  return url.format(parsedUrl);\n}\n\nexport function stripProtocol(urlString) {\n  const protocolEndIndex = urlString.indexOf('//');\n  return protocolEndIndex > -1 ? urlString.slice(protocolEndIndex + 2) : urlString;\n}\n\n/* See https://www.w3.org/International/articles/idn-and-iri/#path.\n * According to the new IRI (Internationalized Resource Identifier) spec, RFC 3987,\n *   ASCII chars should be kept the same way as in standard URIs (letters digits _ - . ~).\n * Non-ASCII chars (unless they are not in the allowed \"ucschars\" list) should be percent-encoded.\n * If the string is not encoded in Unicode, it should be converted to UTF-8 and normalized first,\n *   but JS stores strings as UTF-16/UCS-2 internally, so we should not normallize or re-encode.\n */\nconst uriChars = /[\\w\\-.~]/i;\nconst ucsChars = /[\\xA0-\\u{D7FF}\\u{F900}-\\u{FDCF}\\u{FDF0}-\\u{FFEF}\\u{10000}-\\u{1FFFD}\\u{20000}-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}\\u{50000}-\\u{5FFFD}\\u{60000}-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}\\u{90000}-\\u{9FFFD}\\u{A0000}-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}\\u{D0000}-\\u{DFFFD}\\u{E1000}-\\u{EFFFD}]/u;\nconst validURIChar = char => uriChars.test(char);\nconst validIRIChar = char => uriChars.test(char) || ucsChars.test(char);\n// `sanitizeURI` does not actually URI-encode the chars (that is the browser's and server's job), just removes the ones that are not allowed.\nexport function sanitizeURI(str, { replacement = '', encoding = 'unicode' } = {}) {\n  if (!isString(str)) {\n    throw new Error('The input slug must be a string.');\n  }\n  if (!isString(replacement)) {\n    throw new Error('`options.replacement` must be a string.');\n  }\n\n  let validChar;\n  if (encoding === 'unicode') {\n    validChar = validIRIChar;\n  } else if (encoding === 'ascii') {\n    validChar = validURIChar;\n  } else {\n    throw new Error('`options.encoding` must be \"unicode\" or \"ascii\".');\n  }\n\n  // Check and make sure the replacement character is actually a safe char itself.\n  if (!Array.from(replacement).every(validChar)) {\n    throw new Error('The replacement character(s) (options.replacement) is itself unsafe.');\n  }\n\n  // `Array.from` must be used instead of `String.split` because\n  //   `split` converts things like emojis into UTF-16 surrogate pairs.\n  return Array.from(str)\n    .map(char => (validChar(char) ? char : replacement))\n    .join('');\n}\n\nexport function sanitizeSlug(str, options = Map()) {\n  const encoding = options.get('encoding', 'unicode');\n  const stripDiacritics = options.get('clean_accents', false);\n  const replacement = options.get('sanitize_replacement', '-');\n\n  if (!isString(str)) {\n    throw new Error('The input slug must be a string.');\n  }\n\n  const sanitizedSlug = flow([\n    ...(stripDiacritics ? [diacritics.remove] : []),\n    partialRight(sanitizeURI, { replacement, encoding }),\n    partialRight(sanitizeFilename, { replacement }),\n  ])(str);\n\n  // Remove any doubled or leading/trailing replacement characters (that were added in the sanitizers).\n  const doubleReplacement = new RegExp(`(?:${escapeRegExp(replacement)})+`, 'g');\n  const trailingReplacment = new RegExp(`${escapeRegExp(replacement)}$`);\n  const leadingReplacment = new RegExp(`^${escapeRegExp(replacement)}`);\n\n  const normalizedSlug = sanitizedSlug\n    .replace(doubleReplacement, replacement)\n    .replace(leadingReplacment, '')\n    .replace(trailingReplacment, '');\n\n  return normalizedSlug;\n}\n"],"file":"urlHelper.js"}