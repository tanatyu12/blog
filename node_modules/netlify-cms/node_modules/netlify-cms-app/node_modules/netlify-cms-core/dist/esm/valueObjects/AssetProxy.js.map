{"version":3,"sources":["../../../src/valueObjects/AssetProxy.js"],"names":["AssetProxy","value","fileObj","uploaded","asset","config","store","getState","sha","path","get","public_path","prototype","toString","window","URL","createObjectURL","error","toBase64","Promise","resolve","fr","FileReader","onload","readerEvt","binaryString","target","result","split","readAsDataURL","createAssetProxy","privateUpload","state","integration","provider","integrations","getToken","upload","then","response","url","replace","Error"],"mappings":"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","sourcesContent":["import { resolvePath } from 'netlify-cms-lib-util';\nimport { currentBackend } from 'coreSrc/backend';\nimport store from 'ReduxStore';\nimport { getIntegrationProvider } from 'Integrations';\nimport { selectIntegration } from 'Reducers';\n\nexport default function AssetProxy(value, fileObj, uploaded = false, asset) {\n  const config = store.getState().config;\n  this.value = value;\n  this.fileObj = fileObj;\n  this.uploaded = uploaded;\n  this.sha = null;\n  this.path =\n    config.get('media_folder') && !uploaded\n      ? resolvePath(value, config.get('media_folder'))\n      : value;\n  this.public_path = !uploaded ? resolvePath(value, config.get('public_folder')) : value;\n  this.asset = asset;\n}\n\nAssetProxy.prototype.toString = function() {\n  // Use the deployed image path if we do not have a locally cached copy.\n  if (this.uploaded && !this.fileObj) return this.public_path;\n  try {\n    return window.URL.createObjectURL(this.fileObj);\n  } catch (error) {\n    return null;\n  }\n};\n\nAssetProxy.prototype.toBase64 = function() {\n  return new Promise(resolve => {\n    const fr = new FileReader();\n    fr.onload = readerEvt => {\n      const binaryString = readerEvt.target.result;\n\n      resolve(binaryString.split('base64,')[1]);\n    };\n    fr.readAsDataURL(this.fileObj);\n  });\n};\n\nexport function createAssetProxy(value, fileObj, uploaded = false, privateUpload = false) {\n  const state = store.getState();\n  const integration = selectIntegration(state, null, 'assetStore');\n  if (integration && !uploaded) {\n    const provider =\n      integration &&\n      getIntegrationProvider(\n        state.integrations,\n        currentBackend(state.config).getToken,\n        integration,\n      );\n    return provider\n      .upload(fileObj, privateUpload)\n      .then(\n        response =>\n          new AssetProxy(response.asset.url.replace(/^(https?):/, ''), null, true, response.asset),\n        () => new AssetProxy(value, fileObj, false),\n      );\n  } else if (privateUpload) {\n    throw new Error('The Private Upload option is only avaible for Asset Store Integration');\n  }\n\n  return Promise.resolve(new AssetProxy(value, fileObj, uploaded));\n}\n"],"file":"AssetProxy.js"}