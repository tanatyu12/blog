{"version":3,"sources":["../../../src/serializers/remarkAssertParents.js"],"names":["remarkUnwrapInvalidNest","transform","tree","invalidNest","findInvalidNest","splitTreeAtNest","blocks","canContainBlocks","node","parents","parentType","type","isInvalidNest","includes","nest","grandparent","parent","splitIndex","children","indexOf","splitChildren","splitChildIndex","childrenBefore","slice","childrenAfter","nodeBefore","nodeAfter","childrenToInsert","filter","val","beforeChildren","afterChildren","newChildren"],"mappings":"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","sourcesContent":["import { concat, last, nth, isEmpty } from 'lodash';\nimport visitParents from 'unist-util-visit-parents';\n\n/**\n * remarkUnwrapInvalidNest\n *\n * Some MDAST node types can only be nested within specific node types - for\n * example, a paragraph can't be nested within another paragraph, and a heading\n * can't be nested in a \"strong\" type node. This kind of invalid MDAST can be\n * generated by rehype-remark from invalid HTML.\n *\n * This plugin finds instances of invalid nesting, and unwraps the invalidly\n * nested nodes as far up the parental line as necessary, splitting parent nodes\n * along the way. The resulting node has no invalidly nested nodes, and all\n * validly nested nodes retain their ancestry. Nodes that are emptied as a\n * result of unnesting nodes are removed from the tree.\n */\nexport default function remarkUnwrapInvalidNest() {\n  return transform;\n\n  function transform(tree) {\n    const invalidNest = findInvalidNest(tree);\n\n    if (!invalidNest) return tree;\n\n    splitTreeAtNest(tree, invalidNest);\n\n    return transform(tree);\n  }\n\n  /**\n   * visitParents uses unist-util-visit-parent to check every node in the\n   * tree while having access to every ancestor of the node. This is ideal\n   * for determining whether a block node has an ancestor that should not\n   * contain a block node. Note that it operates in a mutable fashion.\n   */\n  function findInvalidNest(tree) {\n    /**\n     * Node types that are considered \"blocks\".\n     */\n    const blocks = ['paragraph', 'heading', 'code', 'blockquote', 'list', 'table', 'thematicBreak'];\n\n    /**\n     * Node types that can contain \"block\" nodes as direct children. We check\n     */\n    const canContainBlocks = ['root', 'blockquote', 'listItem', 'tableCell'];\n\n    let invalidNest;\n\n    visitParents(tree, (node, parents) => {\n      const parentType = !isEmpty(parents) && last(parents).type;\n      const isInvalidNest = blocks.includes(node.type) && !canContainBlocks.includes(parentType);\n\n      if (isInvalidNest) {\n        invalidNest = concat(parents, node);\n        return false;\n      }\n    });\n\n    return invalidNest;\n  }\n\n  function splitTreeAtNest(tree, nest) {\n    const grandparent = nth(nest, -3) || tree;\n    const parent = nth(nest, -2);\n    const node = last(nest);\n\n    const splitIndex = grandparent.children.indexOf(parent);\n    const splitChildren = grandparent.children;\n    const splitChildIndex = parent.children.indexOf(node);\n\n    const childrenBefore = parent.children.slice(0, splitChildIndex);\n    const childrenAfter = parent.children.slice(splitChildIndex + 1);\n    const nodeBefore = !isEmpty(childrenBefore) && { ...parent, children: childrenBefore };\n    const nodeAfter = !isEmpty(childrenAfter) && { ...parent, children: childrenAfter };\n\n    const childrenToInsert = [nodeBefore, node, nodeAfter].filter(val => !isEmpty(val));\n    const beforeChildren = splitChildren.slice(0, splitIndex);\n    const afterChildren = splitChildren.slice(splitIndex + 1);\n    const newChildren = concat(beforeChildren, childrenToInsert, afterChildren);\n    grandparent.children = newChildren;\n  }\n}\n"],"file":"remarkAssertParents.js"}