{"version":3,"sources":["../../../src/serializers/slateRemark.js"],"names":["typeMap","root","paragraph","quote","code","table","break","link","image","markMap","bold","italic","strikethrough","shortcodePlugins","slateToRemark","raw","opts","type","transform","node","combinedChildren","nodes","combineTextAndInline","children","includes","object","convertTextNode","convertNode","reduce","acc","prevNode","prevNodeLeaves","data","marks","push","leaves","concat","processCodeMark","markTypes","isInlineCode","filteredMarkTypes","textNodeType","processedLeaves","map","processLeaves","i","length","leaf","text","trim","match","leadingWhitespace","trailingWhitespace","every","mark","splice","replace","condensedNodes","condenseNodesReducer","idx","nextIndex","markLengths","getMarkLength","slice","parentMarkLength","parentType","markType","parentLength","newNextIndex","denestedChildren","child","mdastChildren","mdastNode","baseNode","plugin","get","shortcode","toBlock","shortcodeData","textNode","depthMap","one","two","three","four","five","six","depthText","split","depth","value","join","lang","ordered","props","start","url","title","alt"],"mappings":"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","sourcesContent":["import { get, isEmpty, without, flatMap, last, sortBy } from 'lodash';\nimport u from 'unist-builder';\n\n/**\n * Map of Slate node types to MDAST/Remark node types.\n */\nconst typeMap = {\n  root: 'root',\n  paragraph: 'paragraph',\n  'heading-one': 'heading',\n  'heading-two': 'heading',\n  'heading-three': 'heading',\n  'heading-four': 'heading',\n  'heading-five': 'heading',\n  'heading-six': 'heading',\n  quote: 'blockquote',\n  code: 'code',\n  'numbered-list': 'list',\n  'bulleted-list': 'list',\n  'list-item': 'listItem',\n  table: 'table',\n  'table-row': 'tableRow',\n  'table-cell': 'tableCell',\n  break: 'break',\n  'thematic-break': 'thematicBreak',\n  link: 'link',\n  image: 'image',\n};\n\n/**\n * Map of Slate mark types to MDAST/Remark node types.\n */\nconst markMap = {\n  bold: 'strong',\n  italic: 'emphasis',\n  strikethrough: 'delete',\n  code: 'inlineCode',\n};\n\nlet shortcodePlugins;\n\nexport default function slateToRemark(raw, opts) {\n  /**\n   * Set shortcode plugins in outer scope.\n   */\n  ({ shortcodePlugins } = opts);\n\n  /**\n   * The Slate Raw AST generally won't have a top level type, so we set it to\n   * \"root\" for clarity.\n   */\n  raw.type = 'root';\n\n  return transform(raw);\n}\n\n/**\n * The transform function mimics the approach of a Remark plugin for\n * conformity with the other serialization functions. This function converts\n * Slate nodes to MDAST nodes, and recursively calls itself to process child\n * nodes to arbitrary depth.\n */\nfunction transform(node) {\n  /**\n   * Combine adjacent text and inline nodes before processing so they can\n   * share marks.\n   */\n  const combinedChildren = node.nodes && combineTextAndInline(node.nodes);\n\n  /**\n   * Call `transform` recursively on child nodes, and flatten the resulting\n   * array.\n   */\n  const children = !isEmpty(combinedChildren) && flatMap(combinedChildren, transform);\n\n  /**\n   * Run individual nodes through conversion factories.\n   */\n  return ['text'].includes(node.object)\n    ? convertTextNode(node)\n    : convertNode(node, children, shortcodePlugins);\n}\n\n/**\n * Includes inline nodes as leaves in adjacent text nodes where appropriate, so\n * that mark node combining logic can apply to both text and inline nodes. This\n * is necessary because Slate doesn't allow inline nodes to have marks while\n * inline nodes in MDAST may be nested within mark nodes. Treating them as if\n * they were text is a bit of a necessary hack.\n */\nfunction combineTextAndInline(nodes) {\n  return nodes.reduce((acc, node) => {\n    const prevNode = last(acc);\n    const prevNodeLeaves = get(prevNode, 'leaves');\n    const data = node.data || {};\n\n    /**\n     * If the previous node has leaves and the current node has marks in data\n     * (only happens when we place them on inline nodes here in the parser), or\n     * the current node also has leaves (because the previous node was\n     * originally an inline node that we've already squashed into a leaf)\n     * combine the current node into the previous.\n     */\n    if (!isEmpty(prevNodeLeaves) && !isEmpty(data.marks)) {\n      prevNodeLeaves.push({ node, marks: data.marks });\n      return acc;\n    }\n\n    if (!isEmpty(prevNodeLeaves) && !isEmpty(node.leaves)) {\n      prevNode.leaves = prevNodeLeaves.concat(node.leaves);\n      return acc;\n    }\n\n    /**\n     * Break nodes contain a single child text node with a newline character\n     * for visual purposes in the editor, but Remark break nodes have no\n     * children, so we remove the child node here.\n     */\n    if (node.type === 'break') {\n      acc.push({ object: 'inline', type: 'break' });\n      return acc;\n    }\n\n    /**\n     * Convert remaining inline nodes to standalone text nodes with leaves.\n     */\n    if (node.object === 'inline') {\n      acc.push({ object: 'text', leaves: [{ node, marks: data.marks }] });\n      return acc;\n    }\n\n    /**\n     * Only remaining case is an actual text node, can be pushed as is.\n     */\n    acc.push(node);\n    return acc;\n  }, []);\n}\n\n/**\n * Slate treats inline code decoration as a standard mark, but MDAST does\n * not allow inline code nodes to contain children, only a single text\n * value. An MDAST inline code node can be nested within mark nodes such\n * as \"emphasis\" and \"strong\", but it cannot contain them.\n *\n * Because of this, if a \"code\" mark (translated to MDAST \"inlineCode\") is\n * in the markTypes array, we make the base text node an \"inlineCode\" type\n * instead of a standard text node.\n */\nfunction processCodeMark(markTypes) {\n  const isInlineCode = markTypes.includes('inlineCode');\n  const filteredMarkTypes = isInlineCode ? without(markTypes, 'inlineCode') : markTypes;\n  const textNodeType = isInlineCode ? 'inlineCode' : 'html';\n  return { filteredMarkTypes, textNodeType };\n}\n\n/**\n * Converts a Slate Raw text node to an MDAST text node.\n *\n * Slate text nodes without marks often simply have a \"text\" property with\n * the value. In this case the conversion to MDAST is simple. If a Slate\n * text node does not have a \"text\" property, it will instead have a\n * \"leaves\" property containing an array of objects, each with an array of\n * marks, such as \"bold\" or \"italic\", along with a \"text\" property.\n *\n * MDAST instead expresses such marks in a nested structure, with individual\n * nodes for each mark type nested until the deepest mark node, which will\n * contain the text node.\n *\n * To convert a Slate text node's marks to MDAST, we treat each \"leaf\" as a\n * separate text node, convert the text node itself to an MDAST text node,\n * and then recursively wrap the text node for each mark, collecting the results\n * of each leaf in a single array of child nodes.\n *\n * For example, this Slate text node:\n *\n * {\n *   object: 'text',\n *   leaves: [\n *     {\n *       text: 'test',\n *       marks: ['bold', 'italic']\n *     },\n *     {\n *       text: 'test two'\n *     }\n *   ]\n * }\n *\n * ...would be converted to this MDAST nested structure:\n *\n * [\n *   {\n *     type: 'strong',\n *     children: [{\n *       type: 'emphasis',\n *       children: [{\n *         type: 'text',\n *         value: 'test'\n *       }]\n *     }]\n *   },\n *   {\n *     type: 'text',\n *     value: 'test two'\n *   }\n * ]\n *\n * This example also demonstrates how a single Slate node may need to be\n * replaced with multiple MDAST nodes, so the resulting array must be flattened.\n */\nfunction convertTextNode(node) {\n  /**\n   * If the Slate text node has a \"leaves\" property, translate the Slate AST to\n   * a nested MDAST structure. Otherwise, just return an equivalent MDAST text\n   * node.\n   */\n  if (node.leaves) {\n    const processedLeaves = node.leaves.map(processLeaves);\n    // Compensate for Slate including leading and trailing whitespace in styled text nodes, which\n    // cannot be represented in markdown (https://github.com/netlify/netlify-cms/issues/1448)\n    for (let i = 0; i < processedLeaves.length; i += 1) {\n      const leaf = processedLeaves[i];\n      if (leaf.marks.length > 0 && leaf.text && leaf.text.trim() !== leaf.text) {\n        const [, leadingWhitespace, trailingWhitespace] = leaf.text.match(/^(\\s*).*?(\\s*)$/);\n        // Move the leading whitespace to a separate unstyled leaf, unless the current leaf\n        // is preceded by another one with (at least) the same marks applied:\n        if (\n          leadingWhitespace.length > 0 &&\n          (i === 0 ||\n            !leaf.marks.every(\n              mark => processedLeaves[i - 1].marks && processedLeaves[i - 1].marks.includes(mark),\n            ))\n        ) {\n          processedLeaves.splice(i, 0, {\n            text: leadingWhitespace,\n            marks: [],\n            textNodeType: leaf.textNodeType,\n          });\n          i += 1;\n          leaf.text = leaf.text.replace(/^\\s+/, '');\n        }\n        // Move the trailing whitespace to a separate unstyled leaf, unless the current leaf\n        // is followed by another one with (at least) the same marks applied:\n        if (\n          trailingWhitespace.length > 0 &&\n          (i === processedLeaves.length - 1 ||\n            !leaf.marks.every(\n              mark => processedLeaves[i + 1].marks && processedLeaves[i + 1].marks.includes(mark),\n            ))\n        ) {\n          processedLeaves.splice(i + 1, 0, {\n            text: trailingWhitespace,\n            marks: [],\n            textNodeType: leaf.textNodeType,\n          });\n          i += 1;\n          leaf.text = leaf.text.replace(/\\s+$/, '');\n        }\n      }\n    }\n    const condensedNodes = processedLeaves.reduce(condenseNodesReducer, { nodes: [] });\n    return condensedNodes.nodes;\n  }\n\n  if (node.object === 'inline') {\n    return transform(node);\n  }\n\n  return u('html', node.text);\n}\n\n/**\n * Process Slate node leaves in preparation for MDAST transformation.\n */\nfunction processLeaves(leaf) {\n  /**\n   * Get an array of the mark types, converted to their MDAST equivalent\n   * types.\n   */\n  const { marks = [], text } = leaf;\n  const markTypes = marks.map(mark => markMap[mark.type]);\n\n  if (typeof leaf.text === 'string') {\n    /**\n     * Code marks must be removed from the marks array, and the presence of a\n     * code mark changes the text node type that should be used.\n     */\n    const { filteredMarkTypes, textNodeType } = processCodeMark(markTypes);\n    return { text, marks: filteredMarkTypes, textNodeType };\n  }\n\n  return { node: leaf.node, marks: markTypes };\n}\n\n/**\n * Slate's AST doesn't group adjacent text nodes with the same marks - a\n * change in marks from letter to letter, even if some are in common, results\n * in a separate leaf. For example, given \"**a_b_**\", transformation to and\n * from Slate's AST will result in \"**a****_b_**\".\n *\n * MDAST treats styling entities as distinct nodes that contain children, so a\n * \"strong\" node can contain a plain text node with a sibling \"emphasis\" node,\n * which contains more text. This reducer serves to create an optimized nested\n * MDAST without the typical redundancies that Slate's AST would produce if\n * transformed as-is. The reducer can be called recursively to produce nested\n * structures.\n */\nfunction condenseNodesReducer(acc, node, idx, nodes) {\n  /**\n   * Skip any nodes that are being processed as children of an MDAST node\n   * through recursive calls.\n   */\n  if (typeof acc.nextIndex === 'number' && acc.nextIndex > idx) {\n    return acc;\n  }\n\n  /**\n   * Processing for nodes with marks.\n   */\n  if (node.marks && node.marks.length > 0) {\n    /**\n     * For each mark on the current node, get the number of consecutive nodes\n     * (starting with this one) that have the mark. Whichever mark covers the\n     * most nodes is used as the parent node, and the nodes with that mark are\n     * processed as children. If the greatest number of consecutive nodes is\n     * tied between multiple marks, there is no priority as to which goes\n     * first.\n     */\n    const markLengths = node.marks.map(mark => getMarkLength(mark, nodes.slice(idx)));\n    const parentMarkLength = last(sortBy(markLengths, 'length'));\n    const { markType: parentType, length: parentLength } = parentMarkLength;\n\n    /**\n     * Since this and any consecutive nodes with the parent mark are going to\n     * be processed as children of the parent mark, this reducer should simply\n     * return the accumulator until after the last node to be covered by the\n     * new parent node. Here we set the next index that should be processed,\n     * if any.\n     */\n    const newNextIndex = idx + parentLength;\n\n    /**\n     * Get the set of nodes that should be processed as children of the new\n     * parent mark node, run each through the reducer as children of the\n     * parent node, and create the parent MDAST node with the resulting\n     * children.\n     */\n    const children = nodes.slice(idx, newNextIndex);\n    const denestedChildren = children.map(child => ({\n      ...child,\n      marks: without(child.marks, parentType),\n    }));\n    const mdastChildren = denestedChildren.reduce(condenseNodesReducer, { nodes: [], parentType })\n      .nodes;\n    const mdastNode = u(parentType, mdastChildren);\n\n    return { ...acc, nodes: [...acc.nodes, mdastNode], nextIndex: newNextIndex };\n  }\n\n  /**\n   * Create the base text node, and pass in the array of mark types as data\n   * (helpful when optimizing/condensing the final structure).\n   */\n  const baseNode =\n    typeof node.text === 'string'\n      ? u(node.textNodeType, { marks: node.marks }, node.text)\n      : transform(node.node);\n\n  /**\n   * Recursively wrap the base text node in the individual mark nodes, if\n   * any exist.\n   */\n  return { ...acc, nodes: [...acc.nodes, baseNode] };\n}\n\n/**\n * Get the number of consecutive Slate nodes containing a given mark beginning\n * from the first received node.\n */\nfunction getMarkLength(markType, nodes) {\n  let length = 0;\n  while (nodes[length] && nodes[length].marks.includes(markType)) {\n    ++length;\n  }\n  return { markType, length };\n}\n\n/**\n * Convert a single Slate Raw node to an MDAST node. Uses the unist-builder `u`\n * function to create MDAST nodes and parses shortcodes.\n */\nfunction convertNode(node, children, shortcodePlugins) {\n  switch (node.type) {\n    /**\n     * General\n     *\n     * Convert simple cases that only require a type and children, with no\n     * additional properties.\n     */\n    case 'root':\n    case 'paragraph':\n    case 'quote':\n    case 'list-item':\n    case 'table':\n    case 'table-row':\n    case 'table-cell': {\n      return u(typeMap[node.type], children);\n    }\n\n    /**\n     * Shortcodes\n     *\n     * Shortcode nodes only exist in Slate's Raw AST if they were inserted\n     * via the plugin toolbar in memory, so they should always have\n     * shortcode data attached. The \"shortcode\" data property contains the\n     * name of the registered shortcode plugin, and the \"shortcodeData\" data\n     * property contains the data received from the shortcode plugin's\n     * `fromBlock` method when the shortcode node was created.\n     *\n     * Here we get the shortcode plugin from the registry and use it's\n     * `toBlock` method to recreate the original markdown shortcode. We then\n     * insert that text into a new \"html\" type node (a \"text\" type node\n     * might get encoded or escaped by remark-stringify). Finally, we wrap\n     * the \"html\" node in a \"paragraph\" type node, as shortcode nodes must\n     * be alone in their own paragraph.\n     */\n    case 'shortcode': {\n      const { data } = node;\n      const plugin = shortcodePlugins.get(data.shortcode);\n      const text = plugin.toBlock(data.shortcodeData);\n      const textNode = u('html', text);\n      return u('paragraph', { data }, [textNode]);\n    }\n\n    /**\n     * Headings\n     *\n     * Slate schemas don't usually infer basic type info from data, so each\n     * level of heading is a separately named type. The MDAST schema just\n     * has a single \"heading\" type with the depth stored in a \"depth\"\n     * property on the node. Here we derive the depth from the Slate node\n     * type - e.g., for \"heading-two\", we need a depth value of \"2\".\n     */\n    case 'heading-one':\n    case 'heading-two':\n    case 'heading-three':\n    case 'heading-four':\n    case 'heading-five':\n    case 'heading-six': {\n      const depthMap = { one: 1, two: 2, three: 3, four: 4, five: 5, six: 6 };\n      const depthText = node.type.split('-')[1];\n      const depth = depthMap[depthText];\n      return u(typeMap[node.type], { depth }, children);\n    }\n\n    /**\n     * Code Blocks\n     *\n     * Code block nodes have a single text child, and may have a code language\n     * stored in the \"lang\" data property. Here we transfer both the node\n     * value and the \"lang\" data property to the new MDAST node.\n     */\n    case 'code': {\n      const value = flatMap(node.nodes, child => {\n        return flatMap(child.leaves, 'text');\n      }).join('');\n      const { lang, ...data } = get(node, 'data', {});\n      return u(typeMap[node.type], { lang, data }, value);\n    }\n\n    /**\n     * Lists\n     *\n     * Our Slate schema has separate node types for ordered and unordered\n     * lists, but the MDAST spec uses a single type with a boolean \"ordered\"\n     * property to indicate whether the list is numbered. The MDAST spec also\n     * allows for a \"start\" property to indicate the first number used for an\n     * ordered list. Here we translate both values to our Slate schema.\n     */\n    case 'numbered-list':\n    case 'bulleted-list': {\n      const ordered = node.type === 'numbered-list';\n      const props = { ordered, start: get(node.data, 'start') || 1 };\n      return u(typeMap[node.type], props, children);\n    }\n\n    /**\n     * Breaks\n     *\n     * Breaks don't have children. We parse them separately for clarity.\n     */\n    case 'break':\n    case 'thematic-break': {\n      return u(typeMap[node.type]);\n    }\n\n    /**\n     * Links\n     *\n     * The url and title attributes of link nodes are stored in properties on\n     * the node for both Slate and Remark schemas.\n     */\n    case 'link': {\n      const { url, title, ...data } = get(node, 'data', {});\n      return u(typeMap[node.type], { url, title, data }, children);\n    }\n\n    /**\n     * Images\n     *\n     * This transformation is almost identical to that of links, except for the\n     * lack of child nodes and addition of `alt` attribute data. Currently the\n     * CMS handles block images by shortcode, so this case will only apply to\n     * inline images, which currently can only occur through raw markdown\n     * insertion.\n     */\n    case 'image': {\n      const { url, title, alt, ...data } = get(node, 'data', {});\n      return u(typeMap[node.type], { url, title, alt, data });\n    }\n\n    /**\n     * No default case is supplied because an unhandled case should never\n     * occur. In the event that it does, let the error throw (for now).\n     */\n  }\n}\n"],"file":"slateRemark.js"}