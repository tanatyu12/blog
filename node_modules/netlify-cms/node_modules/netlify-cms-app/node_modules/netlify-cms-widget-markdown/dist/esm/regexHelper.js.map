{"version":3,"sources":["../../src/regexHelper.js"],"names":["joinPatternSegments","patterns","map","p","source","join","combinePatterns","replaceWhen","matchPattern","replaceFn","text","invertMatchPattern","split","exp","acc","match","exec","lastEntry","index","addSubstring","input","slice","length","nextIndex","nextText","arr","push","replacedText","entry","isMatch"],"mappings":";;;;;;;;;;;;;AAEA;;;;AAIO,SAASA,mBAAT,CAA6BC,QAA7B,EAAuC;AAC5C,SAAOA,QAAQ,CAACC,GAAT,CAAaC,CAAC,IAAIA,CAAC,CAACC,MAApB,EAA4BC,IAA5B,CAAiC,EAAjC,CAAP;AACD;AAED;;;;;;;AAKO,SAASC,eAAT,CAAyBL,QAAzB,EAAmC;AACxC,SAAOA,QAAQ,CAACC,GAAT,CAAaC,CAAC,IAAK,MAAKA,CAAC,CAACC,MAAO,GAAjC,EAAqCC,IAArC,CAA0C,GAA1C,CAAP;AACD;AAED;;;;;;;;;;;;;;AAYO,SAASE,WAAT,CAAqBC,YAArB,EAAmCC,SAAnC,EAA8CC,IAA9C,EAAoDC,kBAApD,EAAwE;AAC7E;;;;;;;;;;;;AAYA,WAASC,KAAT,CAAeC,GAAf,EAAoBH,IAApB,EAA0BI,GAA1B,EAA+B;AAC7B;;;;AAIA,UAAMC,KAAK,GAAGF,GAAG,CAACG,IAAJ,CAASN,IAAT,CAAd;AACA,UAAMO,SAAS,GAAG,oBAAKH,GAAL,CAAlB;AAEA;;;;AAGA,QAAI,CAACC,KAAL,EAAY,OAAOD,GAAP;AAEZ;;;;;AAIA,QAAIC,KAAK,CAACG,KAAN,KAAgB,CAApB,EAAuB;AACrBC,MAAAA,YAAY,CAACL,GAAD,EAAM,CAAN,EAASC,KAAK,CAAC,CAAD,CAAd,EAAmB,IAAnB,CAAZ;AACD,KAFD,MAEO,IAAI,CAACE,SAAL,EAAgB;AACrB;;;;;;AAMAE,MAAAA,YAAY,CAACL,GAAD,EAAM,CAAN,EAASC,KAAK,CAACK,KAAN,CAAYC,KAAZ,CAAkB,CAAlB,EAAqBN,KAAK,CAACG,KAA3B,CAAT,CAAZ;AACAC,MAAAA,YAAY,CAACL,GAAD,EAAMC,KAAK,CAACG,KAAZ,EAAmBH,KAAK,CAAC,CAAD,CAAxB,EAA6B,IAA7B,CAAZ;AACD,KATM,MASA,IAAIA,KAAK,CAACG,KAAN,KAAgBD,SAAS,CAACC,KAAV,GAAkBD,SAAS,CAACP,IAAV,CAAeY,MAArD,EAA6D;AAClE;;;;;AAKAH,MAAAA,YAAY,CAACL,GAAD,EAAMC,KAAK,CAACG,KAAZ,EAAmBH,KAAK,CAAC,CAAD,CAAxB,EAA6B,IAA7B,CAAZ;AACD,KAPM,MAOA;AACL;;;;;AAKA,YAAMQ,SAAS,GAAGN,SAAS,CAACC,KAAV,GAAkBD,SAAS,CAACP,IAAV,CAAeY,MAAnD;AACA,YAAME,QAAQ,GAAGT,KAAK,CAACK,KAAN,CAAYC,KAAZ,CAAkBE,SAAlB,EAA6BR,KAAK,CAACG,KAAnC,CAAjB;AACAC,MAAAA,YAAY,CAACL,GAAD,EAAMS,SAAN,EAAiBC,QAAjB,CAAZ;AACAL,MAAAA,YAAY,CAACL,GAAD,EAAMC,KAAK,CAACG,KAAZ,EAAmBH,KAAK,CAAC,CAAD,CAAxB,EAA6B,IAA7B,CAAZ;AACD;AAED;;;;;AAGA,WAAOH,KAAK,CAACC,GAAD,EAAMH,IAAN,EAAYI,GAAZ,CAAZ;AACD;AAED;;;;;;AAIA,WAASK,YAAT,CAAsBM,GAAtB,EAA2BP,KAA3B,EAAkCR,IAAlC,EAAuD;AAAA,QAAfK,KAAe,uEAAP,KAAO;AACrDU,IAAAA,GAAG,CAACC,IAAJ,CAAS;AAAER,MAAAA,KAAF;AAASR,MAAAA,IAAT;AAAeK,MAAAA;AAAf,KAAT;AACD;AAED;;;;;;AAIA,QAAMD,GAAG,GAAGF,KAAK,CAACJ,YAAD,EAAeE,IAAf,EAAqB,EAArB,CAAjB;AAEA;;;;AAGA,QAAMO,SAAS,GAAG,oBAAKH,GAAL,CAAlB;AACA,MAAI,CAACG,SAAL,EAAgB,OAAOR,SAAS,CAACC,IAAD,CAAhB;AAEhB,QAAMa,SAAS,GAAGN,SAAS,CAACC,KAAV,GAAkBD,SAAS,CAACP,IAAV,CAAeY,MAAnD;;AACA,MAAIZ,IAAI,CAACY,MAAL,GAAcC,SAAlB,EAA6B;AAC3BT,IAAAA,GAAG,CAACY,IAAJ,CAAS;AAAER,MAAAA,KAAK,EAAEK,SAAT;AAAoBb,MAAAA,IAAI,EAAEA,IAAI,CAACW,KAAL,CAAWE,SAAX;AAA1B,KAAT;AACD;AAED;;;;;;;AAKA,QAAMI,YAAY,GAAGb,GAAG,CAACZ,GAAJ,CAAQ0B,KAAK,IAAI;AACpC,UAAMC,OAAO,GAAGlB,kBAAkB,GAAG,CAACiB,KAAK,CAACb,KAAV,GAAkBa,KAAK,CAACb,KAA1D;AACA,WAAOc,OAAO,GAAGpB,SAAS,CAACmB,KAAK,CAAClB,IAAP,CAAZ,GAA2BkB,KAAK,CAAClB,IAA/C;AACD,GAHoB,CAArB;AAKA;;;;AAGA,SAAOiB,YAAY,CAACtB,IAAb,CAAkB,EAAlB,CAAP;AACD","sourcesContent":["import { last } from 'lodash';\n\n/**\n * Joins an array of regular expressions into a single expression, without\n * altering the received expressions.\n */\nexport function joinPatternSegments(patterns) {\n  return patterns.map(p => p.source).join('');\n}\n\n/**\n * Combines an array of regular expressions into a single expression, wrapping\n * each in a non-capturing group and interposing alternation characters (|) so\n * that each expression is executed separately.\n */\nexport function combinePatterns(patterns) {\n  return patterns.map(p => `(?:${p.source})`).join('|');\n}\n\n/**\n * Modify substrings within a string if they match a (global) pattern. Can be\n * inverted to only modify non-matches.\n *\n * params:\n * matchPattern - regexp - a regular expression to check for matches\n * replaceFn - function - a replacement function that receives a matched\n *   substring and returns a replacement substring\n * text - string - the string to process\n * invertMatchPattern - boolean - if true, non-matching substrings are modified\n *   instead of matching substrings\n */\nexport function replaceWhen(matchPattern, replaceFn, text, invertMatchPattern) {\n  /**\n   * Splits the string into an array of objects with the following shape:\n   *\n   * {\n   *   index: number - the index of the substring within the string\n   *   text: string - the substring\n   *   match: boolean - true if the substring matched `matchPattern`\n   * }\n   *\n   * Loops through matches via recursion (`RegExp.exec` tracks the loop\n   * internally).\n   */\n  function split(exp, text, acc) {\n    /**\n     * Get the next match starting from the end of the last match or start of\n     * string.\n     */\n    const match = exp.exec(text);\n    const lastEntry = last(acc);\n\n    /**\n     * `match` will be null if there are no matches.\n     */\n    if (!match) return acc;\n\n    /**\n     * If the match is at the beginning of the input string, normalize to a data\n     * object with the `match` flag set to `true`, and add to the accumulator.\n     */\n    if (match.index === 0) {\n      addSubstring(acc, 0, match[0], true);\n    } else if (!lastEntry) {\n      /**\n       * If there are no entries in the accumulator, convert the substring before\n       * the match to a data object (without the `match` flag set to true) and\n       * push to the accumulator, followed by a data object for the matching\n       * substring.\n       */\n      addSubstring(acc, 0, match.input.slice(0, match.index));\n      addSubstring(acc, match.index, match[0], true);\n    } else if (match.index === lastEntry.index + lastEntry.text.length) {\n      /**\n       * If the last entry in the accumulator immediately preceded the current\n       * matched substring in the original string, just add the data object for\n       * the matching substring to the accumulator.\n       */\n      addSubstring(acc, match.index, match[0], true);\n    } else {\n      /**\n       * Convert the substring before the match to a data object (without the\n       * `match` flag set to true), followed by a data object for the matching\n       * substring.\n       */\n      const nextIndex = lastEntry.index + lastEntry.text.length;\n      const nextText = match.input.slice(nextIndex, match.index);\n      addSubstring(acc, nextIndex, nextText);\n      addSubstring(acc, match.index, match[0], true);\n    }\n\n    /**\n     * Continue executing the expression.\n     */\n    return split(exp, text, acc);\n  }\n\n  /**\n   * Factory for converting substrings to data objects and adding to an output\n   * array.\n   */\n  function addSubstring(arr, index, text, match = false) {\n    arr.push({ index, text, match });\n  }\n\n  /**\n   * Split the input string to an array of data objects, each representing a\n   * matching or non-matching string.\n   */\n  const acc = split(matchPattern, text, []);\n\n  /**\n   * Process the trailing substring after the final match, if one exists.\n   */\n  const lastEntry = last(acc);\n  if (!lastEntry) return replaceFn(text);\n\n  const nextIndex = lastEntry.index + lastEntry.text.length;\n  if (text.length > nextIndex) {\n    acc.push({ index: nextIndex, text: text.slice(nextIndex) });\n  }\n\n  /**\n   * Map the data objects in the accumulator to their string values, modifying\n   * matched strings with the replacement function. Modifies non-matches if\n   * `invertMatchPattern` is truthy.\n   */\n  const replacedText = acc.map(entry => {\n    const isMatch = invertMatchPattern ? !entry.match : entry.match;\n    return isMatch ? replaceFn(entry.text) : entry.text;\n  });\n\n  /**\n   * Return the joined string.\n   */\n  return replacedText.join('');\n}\n"],"file":"regexHelper.js"}