{"version":3,"sources":["../../../src/serializers/remarkEscapeMarkdownEntities.js"],"names":["patternSegments","htmlOpeningTagEnd","nonEscapePatterns","htmlTags","preformattedHtmlBlocks","escapePatterns","joinedNonEscapePatterns","pattern","RegExp","nonEscapePattern","escapeFunctions","map","escapeDelimiters","escapeAll","escapeAllChars","text","partiallyEscapedMarkdown","escapeCommonChars","escapeLeadingChars","replace","nonEscapeExpression","match","start","end","hasEnd","matchSliceEnd","length","content","slice","escape","delim","result","char","remarkEscapeMarkdownEntities","transform","node","index","data","children","includes","type","value"],"mappings":"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","sourcesContent":["import { has, flow, partial, map } from 'lodash';\nimport { joinPatternSegments, combinePatterns, replaceWhen } from '../regexHelper';\n\n/**\n * Reusable regular expressions segments.\n */\nconst patternSegments = {\n  /**\n   * Matches zero or more HTML attributes followed by the tag close bracket,\n   * which may be prepended by zero or more spaces.  The attributes can use\n   * single or double quotes and may be prepended by zero or more spaces.\n   */\n  htmlOpeningTagEnd: /(?: *\\w+=(?:(?:\"[^\"]*\")|(?:'[^']*')))* *>/,\n};\n\n/**\n * Patterns matching substrings that should not be escaped. Array values must be\n * joined before use.\n */\nconst nonEscapePatterns = {\n  /**\n   * HTML Tags\n   *\n   * Matches HTML opening tags and any attributes. Does not check for contents\n   * between tags or closing tags.\n   */\n  htmlTags: [\n    /**\n     * Matches the beginning of an HTML tag, excluding preformatted tag types.\n     */\n    /<(?!pre|style|script)[\\w]+/,\n\n    /**\n     * Matches attributes.\n     */\n    patternSegments.htmlOpeningTagEnd,\n  ],\n\n  /**\n   * Preformatted HTML Blocks\n   *\n   * Matches HTML blocks with preformatted content. The content of these blocks,\n   * including the tags and attributes, should not be escaped at all.\n   */\n  preformattedHtmlBlocks: [\n    /**\n     * Matches the names of tags known to have preformatted content. The capture\n     * group is reused when matching the closing tag.\n     *\n     * NOTE: this pattern reuses a capture group, and could break if combined with\n     * other expressions using capture groups.\n     */\n    /<(pre|style|script)/,\n\n    /**\n     * Matches attributes.\n     */\n    patternSegments.htmlOpeningTagEnd,\n\n    /**\n     * Allow zero or more of any character (including line breaks) between the\n     * tags. Match lazily in case of subsequent blocks.\n     */\n    /(.|[\\n\\r])*?/,\n\n    /**\n     * Match closing tag via first capture group.\n     */\n    /<\\/\\1>/,\n  ],\n};\n\n/**\n * Escape patterns\n *\n * Each escape pattern matches a markdown entity and captures up to two\n * groups. These patterns must use one of the following formulas:\n *\n * - Single capture group followed by match content - /(...).../\n *   The captured characters should be escaped and the remaining match should\n *   remain unchanged.\n *\n * - Two capture groups surrounding matched content - /(...)...(...)/\n *   The captured characters in both groups should be escaped and the matched\n *   characters in between should remain unchanged.\n */\nconst escapePatterns = [\n  /**\n   * Emphasis/Bold - Asterisk\n   *\n   * Match strings surrounded by one or more asterisks on both sides.\n   */\n  /(\\*+)[^*]*(\\1)/g,\n\n  /**\n   * Emphasis - Underscore\n   *\n   * Match strings surrounded by a single underscore on both sides followed by\n   * a word boundary. Remark disregards whether a word boundary exists at the\n   * beginning of an emphasis node.\n   */\n  /(_)[^_]+(_)\\b/g,\n\n  /**\n   * Bold - Underscore\n   *\n   * Match strings surrounded by multiple underscores on both sides. Remark\n   * disregards the absence of word boundaries on either side of a bold node.\n   */\n  /(_{2,})[^_]*(\\1)/g,\n\n  /**\n   * Strikethrough\n   *\n   * Match strings surrounded by multiple tildes on both sides.\n   */\n  /(~+)[^~]*(\\1)/g,\n\n  /**\n   * Inline Code\n   *\n   * Match strings surrounded by backticks.\n   */\n  /(`+)[^`]*(\\1)/g,\n\n  /**\n   * Links, Images, References, and Footnotes\n   *\n   * Match strings surrounded by brackets. This could be improved to\n   * specifically match only the exact syntax of each covered entity, but\n   * doing so through current approach would incur a considerable performance\n   * penalty.\n   */\n  /(\\[)[^\\]]*]/g,\n];\n\n/**\n * Generate new non-escape expression. The non-escape expression matches\n * substrings whose contents should not be processed for escaping.\n */\nconst joinedNonEscapePatterns = map(nonEscapePatterns, pattern => {\n  return new RegExp(joinPatternSegments(pattern));\n});\nconst nonEscapePattern = combinePatterns(joinedNonEscapePatterns);\n\n/**\n * Create chain of successive escape functions for various markdown entities.\n */\nconst escapeFunctions = escapePatterns.map(pattern => partial(escapeDelimiters, pattern));\nconst escapeAll = flow(escapeFunctions);\n\n/**\n * Executes both the `escapeCommonChars` and `escapeLeadingChars` functions.\n */\nfunction escapeAllChars(text) {\n  const partiallyEscapedMarkdown = escapeCommonChars(text);\n  return escapeLeadingChars(partiallyEscapedMarkdown);\n}\n\n/**\n * escapeLeadingChars\n *\n * Handles escaping for characters that must be positioned at the beginning of\n * the string, such as headers and list items.\n *\n * Escapes '#', '*', '-', '>', '=', '|', and sequences of 3+ backticks or 4+\n * spaces when found at the beginning of a string, preceded by zero or more\n * whitespace characters.\n */\nfunction escapeLeadingChars(text) {\n  return text.replace(/^\\s*([-#*>=|]| {4,}|`{3,})/, '$`\\\\$1');\n}\n\n/**\n * escapeCommonChars\n *\n * Escapes active markdown entities. See escape pattern groups for details on\n * which entities are replaced.\n */\nfunction escapeCommonChars(text) {\n  /**\n   * Generate new non-escape expression (must happen at execution time because\n   * we use `RegExp.exec`, which tracks it's own state internally).\n   */\n  const nonEscapeExpression = new RegExp(nonEscapePattern, 'gm');\n\n  /**\n   * Use `replaceWhen` to escape markdown entities only within substrings that\n   * are eligible for escaping.\n   */\n  return replaceWhen(nonEscapeExpression, escapeAll, text, true);\n}\n\n/**\n * escapeDelimiters\n *\n * Executes `String.replace` for a given pattern, but only on the first two\n * capture groups. Specifically intended for escaping opening (and optionally\n * closing) markdown entities without escaping the content in between.\n */\nfunction escapeDelimiters(pattern, text) {\n  return text.replace(pattern, (match, start, end) => {\n    const hasEnd = typeof end === 'string';\n    const matchSliceEnd = hasEnd ? match.length - end.length : match.length;\n    const content = match.slice(start.length, matchSliceEnd);\n    return `${escape(start)}${content}${hasEnd ? escape(end) : ''}`;\n  });\n}\n\n/**\n * escape\n *\n * Simple replacement function for escaping markdown entities. Prepends every\n * character in the received string with a backslash.\n */\nfunction escape(delim) {\n  let result = '';\n  for (const char of delim) {\n    result += `\\\\${char}`;\n  }\n  return result;\n}\n\n/**\n * A Remark plugin for escaping markdown entities.\n *\n * When markdown entities are entered in raw markdown, they don't appear as\n * characters in the resulting AST; for example, dashes surrounding a piece of\n * text cause the text to be inserted in a special node type, but the asterisks\n * themselves aren't present as text. Therefore, we generally don't expect to\n * encounter markdown characters in text nodes.\n *\n * However, the CMS visual editor does not interpret markdown characters, and\n * users will expect these characters to be represented literally. In that case,\n * we need to escape them, otherwise they'll be interpreted during\n * stringification.\n */\nexport default function remarkEscapeMarkdownEntities() {\n  const transform = (node, index) => {\n    /**\n     * Shortcode nodes will intentionally inject markdown entities in text node\n     * children not be escaped.\n     */\n    if (has(node.data, 'shortcode')) return node;\n\n    const children = node.children && node.children.map(transform);\n\n    /**\n     * Escape characters in text and html nodes only. We store a lot of normal\n     * text in html nodes to keep Remark from escaping html entities.\n     */\n    if (['text', 'html'].includes(node.type)) {\n      /**\n       * Escape all characters if this is the first child node, otherwise only\n       * common characters.\n       */\n      const value = index === 0 ? escapeAllChars(node.value) : escapeCommonChars(node.value);\n      return { ...node, value, children };\n    }\n\n    /**\n     * Always return nodes with recursively mapped children.\n     */\n    return { ...node, children };\n  };\n\n  return transform;\n}\n"],"file":"remarkEscapeMarkdownEntities.js"}