{"version":3,"sources":["../../../src/serializers/remarkPaddedLinks.js"],"names":["remarkPaddedLinks","transform","node","children","hasLinkChild","some","child","type","processedChildren","transformChildren","map","text","leadingWhitespaceNode","getEdgeTextChild","trailingWhitespaceNode","value","nodes","filter","val","end","findFn","edgeChildWithValue","setEdgeChildWithValue"],"mappings":";;;;;;;;;;;;;;;;;;;;;AACA;;AACA;;;;;;;;AAEA;;;;;;;;;AASe,SAASA,iBAAT,GAA6B;AAC1C,WAASC,SAAT,CAAmBC,IAAnB,EAAyB;AACvB;;;;AAIA,QAAI,CAACA,IAAI,CAACC,QAAV,EAAoB,OAAOD,IAAP;AAEpB;;;;;;;;;;;AAUA,UAAME,YAAY,GAAGF,IAAI,CAACC,QAAL,CAAcE,IAAd,CAAmBC,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAe,MAA3C,CAArB;AACA,UAAMC,iBAAiB,GAAGJ,YAAY,GAClC,uBAAQF,IAAI,CAACC,QAAb,EAAuBM,iBAAvB,CADkC,GAElCP,IAAI,CAACC,QAFT;AAIA;;;;AAGA,UAAMA,QAAQ,GAAGK,iBAAiB,CAACE,GAAlB,CAAsBT,SAAtB,CAAjB;AAEA,6BAAYC,IAAZ;AAAkBC,MAAAA;AAAlB;AACD;;AAED,WAASM,iBAAT,CAA2BP,IAA3B,EAAiC;AAC/B,QAAIA,IAAI,CAACK,IAAL,KAAc,MAAlB,EAA0B,OAAOL,IAAP;AAE1B;;;;;AAIA,UAAMS,IAAI,GAAG,gCAAST,IAAT,CAAb;AACA,UAAMU,qBAAqB,GAAG,0BAAWD,IAAX,EAAiB,GAAjB,KAAyBE,gBAAgB,CAACX,IAAD,CAAvE;AACA,UAAMY,sBAAsB,GAAG,wBAASH,IAAT,EAAe,GAAf,KAAuBE,gBAAgB,CAACX,IAAD,EAAO,IAAP,CAAtE;AAEA,QAAI,CAACU,qBAAD,IAA0B,CAACE,sBAA/B,EAAuD,OAAOZ,IAAP;AAEvD;;;;;;AAKA,QAAIU,qBAAJ,EAA2B;AACzBA,MAAAA,qBAAqB,CAACG,KAAtB,GAA8B,yBAAUH,qBAAqB,CAACG,KAAhC,CAA9B;AACD;;AAED,QAAID,sBAAJ,EAA4B;AAC1BA,MAAAA,sBAAsB,CAACC,KAAvB,GAA+B,uBAAQD,sBAAsB,CAACC,KAA/B,CAA/B;AACD;AAED;;;;;;AAIA,UAAMC,KAAK,GAAG,CACZJ,qBAAqB,IAAI,2BAAE,MAAF,EAAU,GAAV,CADb,EAEZV,IAFY,EAGZY,sBAAsB,IAAI,2BAAE,MAAF,EAAU,GAAV,CAHd,CAAd;AAMA,WAAOE,KAAK,CAACC,MAAN,CAAaC,GAAG,IAAIA,GAApB,CAAP;AACD;AAED;;;;;;AAIA,WAASL,gBAAT,CAA0BX,IAA1B,EAAgCiB,GAAhC,EAAqC;AACnC;;;;;;AAMA,QAAIC,MAAJ;;AACA,QAAID,GAAJ,EAAS;AACPC,MAAAA,MAAM,qBAAN;AACD,KAFD,MAEO;AACLA,MAAAA,MAAM,iBAAN;AACD;;AAED,QAAIC,kBAAJ;AACAC,IAAAA,qBAAqB,CAACpB,IAAD,CAArB;AACA,WAAOmB,kBAAP;AAEA;;;;;;;AAMA,aAASC,qBAAT,CAA+BhB,KAA/B,EAAsC;AACpC,UAAI,CAACe,kBAAD,IAAuBf,KAAK,CAACS,KAAjC,EAAwC;AACtCM,QAAAA,kBAAkB,GAAGf,KAArB;AACD;;AACDc,MAAAA,MAAM,CAACd,KAAK,CAACH,QAAP,EAAiBmB,qBAAjB,CAAN;AACD;AACF;;AACD,SAAOrB,SAAP;AACD","sourcesContent":["import { find, findLast, startsWith, endsWith, trimStart, trimEnd, flatMap } from 'lodash';\nimport u from 'unist-builder';\nimport toString from 'mdast-util-to-string';\n\n/**\n * Convert leading and trailing spaces in a link to single spaces outside of the\n * link. MDASTs derived from pasted Google Docs HTML require this treatment.\n *\n * Note that, because we're potentially replacing characters in a link node's\n * children with character's in a link node's siblings, we have to operate on a\n * parent (link) node and its children at once, rather than just processing\n * children one at a time.\n */\nexport default function remarkPaddedLinks() {\n  function transform(node) {\n    /**\n     * Because we're operating on link nodes and their children at once, we can\n     * exit if the current node has no children.\n     */\n    if (!node.children) return node;\n\n    /**\n     * Process a node's children if any of them are links. If a node is a link\n     * with leading or trailing spaces, we'll get back an array of nodes instead\n     * of a single node, so we use `flatMap` to keep those nodes as siblings\n     * with the other children.\n     *\n     * If performance improvements are found desirable, we could change this to\n     * only pass in the link nodes instead of the entire array of children, but\n     * this seems unlikely to produce a noticeable perf gain.\n     */\n    const hasLinkChild = node.children.some(child => child.type === 'link');\n    const processedChildren = hasLinkChild\n      ? flatMap(node.children, transformChildren)\n      : node.children;\n\n    /**\n     * Run all children through the transform recursively.\n     */\n    const children = processedChildren.map(transform);\n\n    return { ...node, children };\n  }\n\n  function transformChildren(node) {\n    if (node.type !== 'link') return node;\n\n    /**\n     * Get the node's complete string value, check for leading and trailing\n     * whitespace, and get nodes from each edge where whitespace is found.\n     */\n    const text = toString(node);\n    const leadingWhitespaceNode = startsWith(text, ' ') && getEdgeTextChild(node);\n    const trailingWhitespaceNode = endsWith(text, ' ') && getEdgeTextChild(node, true);\n\n    if (!leadingWhitespaceNode && !trailingWhitespaceNode) return node;\n\n    /**\n     * Trim the edge nodes in place. Unified handles everything in a mutable\n     * fashion, so it's often simpler to do the same when working with Unified\n     * ASTs.\n     */\n    if (leadingWhitespaceNode) {\n      leadingWhitespaceNode.value = trimStart(leadingWhitespaceNode.value);\n    }\n\n    if (trailingWhitespaceNode) {\n      trailingWhitespaceNode.value = trimEnd(trailingWhitespaceNode.value);\n    }\n\n    /**\n     * Create an array of nodes. The first and last child will either be `false`\n     * or a text node. We filter out the false values before returning.\n     */\n    const nodes = [\n      leadingWhitespaceNode && u('text', ' '),\n      node,\n      trailingWhitespaceNode && u('text', ' '),\n    ];\n\n    return nodes.filter(val => val);\n  }\n\n  /**\n   * Get the first or last non-blank text child of a node, regardless of\n   * nesting. If `end` is truthy, get the last node, otherwise first.\n   */\n  function getEdgeTextChild(node, end) {\n    /**\n     * This was changed from a ternary to a long form if due to issues with istanbul's instrumentation and babel's code\n     * generation.\n     * TODO: watch https://github.com/istanbuljs/babel-plugin-istanbul/issues/95\n     * when it is resolved then revert to ```const findFn = end ? findLast : find;```\n     */\n    let findFn;\n    if (end) {\n      findFn = findLast;\n    } else {\n      findFn = find;\n    }\n\n    let edgeChildWithValue;\n    setEdgeChildWithValue(node);\n    return edgeChildWithValue;\n\n    /**\n     * searchChildren checks a node and all of it's children deeply to find a\n     * non-blank text value. When the text node is found, we set it in an outside\n     * variable, as it may be deep in the tree and therefore wouldn't be returned\n     * by `find`/`findLast`.\n     */\n    function setEdgeChildWithValue(child) {\n      if (!edgeChildWithValue && child.value) {\n        edgeChildWithValue = child;\n      }\n      findFn(child.children, setEdgeChildWithValue);\n    }\n  }\n  return transform;\n}\n"],"file":"remarkPaddedLinks.js"}