{"version":3,"sources":["../../../src/serializers/remarkSlate.js"],"names":["remarkToSlate","transform","node","children","includes","type","filter","val","convertNode","typeMap","root","paragraph","blockquote","code","listItem","table","tableRow","tableCell","thematicBreak","link","image","shortcode","markMap","strong","emphasis","delete","inlineCode","addNodes","parent","nodes","createBlock","props","undefined","object","createInline","createText","value","data","leaves","text","processMarkNode","parentMarks","markType","marks","childNode","childMarks","convertMarkNode","slateNodes","convertedSlateNodes","reduce","acc","lastConvertedNode","push","isVoid","leaf","depthMap","slateType","depth","lang","ordered","start","textNode","title","url","newData","alt","align"],"mappings":"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","sourcesContent":["import { get, isEmpty, isArray, last, flatMap } from 'lodash';\n\n/**\n * A Remark plugin for converting an MDAST to Slate Raw AST. Remark plugins\n * return a `transform` function that receives the MDAST as it's first argument.\n */\nexport default function remarkToSlate() {\n  return transform;\n}\n\nfunction transform(node) {\n  /**\n   * Call `transform` recursively on child nodes.\n   *\n   * If a node returns a falsey value, filter it out. Some nodes do not\n   * translate from MDAST to Slate, such as definitions for link/image\n   * references or footnotes.\n   */\n  const children =\n    !['strong', 'emphasis', 'delete'].includes(node.type) &&\n    !isEmpty(node.children) &&\n    flatMap(node.children, transform).filter(val => val);\n\n  /**\n   * Run individual nodes through the conversion factory.\n   */\n  return convertNode(node, children);\n}\n\n/**\n * Map of MDAST node types to Slate node types.\n */\nconst typeMap = {\n  root: 'root',\n  paragraph: 'paragraph',\n  blockquote: 'quote',\n  code: 'code',\n  listItem: 'list-item',\n  table: 'table',\n  tableRow: 'table-row',\n  tableCell: 'table-cell',\n  thematicBreak: 'thematic-break',\n  link: 'link',\n  image: 'image',\n  shortcode: 'shortcode',\n};\n\n/**\n * Map of MDAST node types to Slate mark types.\n */\nconst markMap = {\n  strong: 'bold',\n  emphasis: 'italic',\n  delete: 'strikethrough',\n  inlineCode: 'code',\n};\n\n/**\n * Add nodes to a parent node only if `nodes` is truthy.\n */\nfunction addNodes(parent, nodes) {\n  return nodes ? { ...parent, nodes } : parent;\n}\n\n/**\n * Create a Slate Inline node.\n */\nfunction createBlock(type, nodes, props = {}) {\n  if (!isArray(nodes)) {\n    props = nodes;\n    nodes = undefined;\n  }\n\n  const node = { object: 'block', type, ...props };\n  return addNodes(node, nodes);\n}\n\n/**\n * Create a Slate Block node.\n */\nfunction createInline(type, props = {}, nodes) {\n  const node = { object: 'inline', type, ...props };\n  return addNodes(node, nodes);\n}\n\n/**\n * Create a Slate Raw text node.\n */\nfunction createText(value, data) {\n  const node = { object: 'text', data };\n  const leaves = isArray(value) ? value : [{ text: value }];\n  return { ...node, leaves };\n}\n\nfunction processMarkNode(node, parentMarks = []) {\n  /**\n   * Add the current node's mark type to the marks collected from parent\n   * mark nodes, if any.\n   */\n  const markType = markMap[node.type];\n  const marks = markType ? [...parentMarks, { type: markMap[node.type] }] : parentMarks;\n\n  const children = flatMap(node.children, childNode => {\n    switch (childNode.type) {\n      /**\n       * If a text node is a direct child of the current node, it should be\n       * set aside as a leaf, and all marks that have been collected in the\n       * `marks` array should apply to that specific leaf.\n       */\n      case 'html':\n      case 'text':\n        return { text: childNode.value, marks };\n\n      /**\n       * MDAST inline code nodes don't have children, just a text value, similar\n       * to a text node, so it receives the same treatment as a text node, but we\n       * first add the inline code mark to the marks array.\n       */\n      case 'inlineCode': {\n        const childMarks = [...marks, { type: markMap['inlineCode'] }];\n        return { text: childNode.value, marks: childMarks };\n      }\n\n      /**\n       * Process nested style nodes. The recursive results should be pushed into\n       * the leaves array. This way, every MDAST nested text structure becomes a\n       * flat array of leaves that can serve as the value of a single Slate Raw\n       * text node.\n       */\n      case 'strong':\n      case 'emphasis':\n      case 'delete':\n        return processMarkNode(childNode, marks);\n\n      /**\n       * Remaining nodes simply need mark data added to them, and to then be\n       * added into the cumulative children array.\n       */\n      default:\n        return { ...childNode, data: { marks } };\n    }\n  });\n\n  return children;\n}\n\nfunction convertMarkNode(node) {\n  const slateNodes = processMarkNode(node);\n\n  const convertedSlateNodes = slateNodes.reduce((acc, node) => {\n    const lastConvertedNode = last(acc);\n    if (node.text && lastConvertedNode && lastConvertedNode.leaves) {\n      lastConvertedNode.leaves.push(node);\n    } else if (node.text) {\n      acc.push(createText([node]));\n    } else {\n      acc.push(transform(node));\n    }\n\n    return acc;\n  }, []);\n\n  return convertedSlateNodes;\n}\n\n/**\n * Convert a single MDAST node to a Slate Raw node. Uses local node factories\n * that mimic the unist-builder function utilized in the slateRemark\n * transformer.\n */\nfunction convertNode(node, nodes) {\n  /**\n   * Unified/Remark processors use mutable operations, so we don't want to\n   * change a node's type directly for conversion purposes, as that tends to\n   * unexpected errors.\n   */\n  const type = get(node, ['data', 'shortcode']) ? 'shortcode' : node.type;\n\n  switch (type) {\n    /**\n     * General\n     *\n     * Convert simple cases that only require a type and children, with no\n     * additional properties.\n     */\n    case 'root':\n    case 'paragraph':\n    case 'listItem':\n    case 'blockquote':\n    case 'tableRow':\n    case 'tableCell': {\n      return createBlock(typeMap[type], nodes);\n    }\n\n    /**\n     * Shortcodes\n     *\n     * Shortcode nodes are represented as \"void\" blocks in the Slate AST. They\n     * maintain the same data as MDAST shortcode nodes. Slate void blocks must\n     * contain a blank text node.\n     */\n    case 'shortcode': {\n      const { data } = node;\n      const nodes = [createText('')];\n      return createBlock(typeMap[type], nodes, { data, isVoid: true });\n    }\n\n    /**\n     * Text\n     *\n     * Text and HTML nodes are both used to render text, and should be treated\n     * the same. HTML is treated as text because we never want to escape or\n     * encode it.\n     */\n    case 'text':\n    case 'html': {\n      return createText(node.value, node.data);\n    }\n\n    /**\n     * Inline Code\n     *\n     * Inline code nodes from an MDAST are represented in our Slate schema as\n     * text nodes with a \"code\" mark. We manually create the \"leaf\" containing\n     * the inline code value and a \"code\" mark, and place it in an array for use\n     * as a Slate text node's children array.\n     */\n    case 'inlineCode': {\n      const leaf = {\n        text: node.value,\n        marks: [{ type: 'code' }],\n      };\n      return createText([leaf]);\n    }\n\n    /**\n     * Marks\n     *\n     * Marks are typically decorative sub-types that apply to text nodes. In an\n     * MDAST, marks are nodes that can contain other nodes. This nested\n     * hierarchy has to be flattened and split into distinct text nodes with\n     * their own set of marks.\n     */\n    case 'strong':\n    case 'emphasis':\n    case 'delete': {\n      return convertMarkNode(node);\n    }\n\n    /**\n     * Headings\n     *\n     * MDAST headings use a single type with a separate \"depth\" property to\n     * indicate the heading level, while the Slate schema uses a separate node\n     * type for each heading level. Here we get the proper Slate node name based\n     * on the MDAST node depth.\n     */\n    case 'heading': {\n      const depthMap = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six' };\n      const slateType = `heading-${depthMap[node.depth]}`;\n      return createBlock(slateType, nodes);\n    }\n\n    /**\n     * Code Blocks\n     *\n     * MDAST code blocks are a distinct node type with a simple text value. We\n     * convert that value into a nested child text node for Slate. We also carry\n     * over the \"lang\" data property if it's defined.\n     */\n    case 'code': {\n      const data = { lang: node.lang };\n      const text = createText(node.value);\n      const nodes = [text];\n      return createBlock(typeMap[type], nodes, { data });\n    }\n\n    /**\n     * Lists\n     *\n     * MDAST has a single list type and an \"ordered\" property. We derive that\n     * information into the Slate schema's distinct list node types. We also\n     * include the \"start\" property, which indicates the number an ordered list\n     * starts at, if defined.\n     */\n    case 'list': {\n      const slateType = node.ordered ? 'numbered-list' : 'bulleted-list';\n      const data = { start: node.start };\n      return createBlock(slateType, nodes, { data });\n    }\n\n    /**\n     * Breaks\n     *\n     * MDAST soft break nodes represent a trailing double space or trailing\n     * slash from a Markdown document. In Slate, these are simply transformed to\n     * line breaks within a text node.\n     */\n    case 'break': {\n      const textNode = createText('\\n');\n      return createInline('break', {}, [textNode]);\n    }\n\n    /**\n     * Thematic Breaks\n     *\n     * Thematic breaks are void nodes in the Slate schema.\n     */\n    case 'thematicBreak': {\n      return createBlock(typeMap[type], { isVoid: true });\n    }\n\n    /**\n     * Links\n     *\n     * MDAST stores the link attributes directly on the node, while our Slate\n     * schema references them in the data object.\n     */\n    case 'link': {\n      const { title, url, data } = node;\n      const newData = { ...data, title, url };\n      return createInline(typeMap[type], { data: newData }, nodes);\n    }\n\n    /**\n     * Images\n     *\n     * Identical to link nodes except for the lack of child nodes and addition\n     * of alt attribute data MDAST stores the link attributes directly on the\n     * node, while our Slate schema references them in the data object.\n     */\n    case 'image': {\n      const { title, url, alt, data } = node;\n      const newData = { ...data, title, alt, url };\n      return createInline(typeMap[type], { isVoid: true, data: newData });\n    }\n\n    /**\n     * Tables\n     *\n     * Tables are parsed separately because they may include an \"align\"\n     * property, which should be passed to the Slate node.\n     */\n    case 'table': {\n      const data = { align: node.align };\n      return createBlock(typeMap[type], nodes, { data });\n    }\n  }\n}\n"],"file":"remarkSlate.js"}