{"version":3,"sources":["../../../src/serializers/remarkShortcodes.js"],"names":["remarkShortcodes","plugins","transform","root","transformedChildren","children","processShortcodes","node","nodeMayContainShortcode","text","trim","matchTextToPlugin","plugin","match","matchIsValid","validateMatch","createShortcodeNode","validNodeTypes","validChildTypes","includes","type","child","find","p","pattern","length","shortcode","id","shortcodeData","fromBlock","data","textNode"],"mappings":";;;;;;;;;;;AACA;;AACA;;;;;;;;AAEA;;;;;;;;;AASe,SAASA,gBAAT,OAAuC;AAAA,MAAXC,OAAW,QAAXA,OAAW;AACpD,SAAOC,SAAP;AAEA;;;;AAGA,WAASA,SAAT,CAAmBC,IAAnB,EAAyB;AACvB,UAAMC,mBAAmB,GAAG,mBAAID,IAAI,CAACE,QAAT,EAAmBC,iBAAnB,CAA5B;AACA,6BAAYH,IAAZ;AAAkBE,MAAAA,QAAQ,EAAED;AAA5B;AACD;AAED;;;;;AAGA,WAASE,iBAAT,CAA2BC,IAA3B,EAAiC;AAC/B;;;;AAIA,QAAI,CAACC,uBAAuB,CAACD,IAAD,CAA5B,EAAoC,OAAOA,IAAP;AAEpC;;;;;AAIA,UAAME,IAAI,GAAG,gCAAcF,IAAd,EAAoBG,IAApB,EAAb;;AAX+B,+BAYLC,iBAAiB,CAACF,IAAD,CAZZ;AAAA,UAYvBG,MAZuB,sBAYvBA,MAZuB;AAAA,UAYfC,KAZe,sBAYfA,KAZe;;AAa/B,UAAMC,YAAY,GAAGC,aAAa,CAACN,IAAD,EAAOI,KAAP,CAAlC;AAEA;;;;;AAIA,WAAOC,YAAY,GAAGE,mBAAmB,CAACP,IAAD,EAAOG,MAAP,EAAeC,KAAf,CAAtB,GAA8CN,IAAjE;AACD;AAED;;;;;;;AAKA,WAASC,uBAAT,CAAiCD,IAAjC,EAAuC;AACrC,UAAMU,cAAc,GAAG,CAAC,WAAD,CAAvB;AACA,UAAMC,eAAe,GAAG,CAAC,MAAD,EAAS,MAAT,CAAxB;;AAEA,QAAID,cAAc,CAACE,QAAf,CAAwBZ,IAAI,CAACa,IAA7B,CAAJ,EAAwC;AACtC,aAAO,qBAAMb,IAAI,CAACF,QAAX,EAAqBgB,KAAK,IAAI;AACnC,eAAOH,eAAe,CAACC,QAAhB,CAAyBE,KAAK,CAACD,IAA/B,CAAP;AACD,OAFM,CAAP;AAGD;AACF;AAED;;;;;;AAIA,WAAST,iBAAT,CAA2BF,IAA3B,EAAiC;AAC/B,QAAII,KAAJ;AACA,UAAMD,MAAM,GAAGX,OAAO,CAACqB,IAAR,CAAaC,CAAC,IAAI;AAC/BV,MAAAA,KAAK,GAAGJ,IAAI,CAACI,KAAL,CAAWU,CAAC,CAACC,OAAb,CAAR;AACA,aAAO,CAAC,CAACX,KAAT;AACD,KAHc,CAAf;AAIA,WAAO;AAAED,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KAAP;AACD;AAED;;;;;AAGA,WAASE,aAAT,CAAuBN,IAAvB,EAA6BI,KAA7B,EAAoC;AAClC,WAAOA,KAAK,IAAIA,KAAK,CAAC,CAAD,CAAL,CAASY,MAAT,KAAoBhB,IAAI,CAACgB,MAAzC;AACD;AAED;;;;;;;;AAMA,WAAST,mBAAT,CAA6BP,IAA7B,EAAmCG,MAAnC,EAA2CC,KAA3C,EAAkD;AAChD,UAAMa,SAAS,GAAGd,MAAM,CAACe,EAAzB;AACA,UAAMC,aAAa,GAAGhB,MAAM,CAACiB,SAAP,CAAiBhB,KAAjB,CAAtB;AACA,UAAMiB,IAAI,GAAG;AAAEJ,MAAAA,SAAF;AAAaE,MAAAA;AAAb,KAAb;AACA,UAAMG,QAAQ,GAAG,2BAAE,MAAF,EAAUtB,IAAV,CAAjB;AACA,WAAO,2BAAE,WAAF,EAAe;AAAEqB,MAAAA;AAAF,KAAf,EAAyB,CAACC,QAAD,CAAzB,CAAP;AACD;AACF","sourcesContent":["import { map, every } from 'lodash';\nimport u from 'unist-builder';\nimport mdastToString from 'mdast-util-to-string';\n\n/**\n * Parse shortcodes from an MDAST.\n *\n * Shortcodes are plain text, and must be the lone content of a paragraph. The\n * paragraph must also be a direct child of the root node. When a shortcode is\n * found, we just need to add data to the node so the shortcode can be\n * identified and processed when serializing to a new format. The paragraph\n * containing the node is also recreated to ensure normalization.\n */\nexport default function remarkShortcodes({ plugins }) {\n  return transform;\n\n  /**\n   * Map over children of the root node and convert any found shortcode nodes.\n   */\n  function transform(root) {\n    const transformedChildren = map(root.children, processShortcodes);\n    return { ...root, children: transformedChildren };\n  }\n\n  /**\n   * Mapping function to transform nodes that contain shortcodes.\n   */\n  function processShortcodes(node) {\n    /**\n     * If the node is not eligible to contain a shortcode, return the original\n     * node unchanged.\n     */\n    if (!nodeMayContainShortcode(node)) return node;\n\n    /**\n     * Combine the text values of all children to a single string, check the\n     * string for a shortcode pattern match, and validate the match.\n     */\n    const text = mdastToString(node).trim();\n    const { plugin, match } = matchTextToPlugin(text);\n    const matchIsValid = validateMatch(text, match);\n\n    /**\n     * If a valid match is found, return a new node with shortcode data\n     * included. Otherwise, return the original node.\n     */\n    return matchIsValid ? createShortcodeNode(text, plugin, match) : node;\n  }\n\n  /**\n   * Ensure that the node and it's children are acceptable types to contain\n   * shortcodes. Currently, only a paragraph containing text and/or html nodes\n   * may contain shortcodes.\n   */\n  function nodeMayContainShortcode(node) {\n    const validNodeTypes = ['paragraph'];\n    const validChildTypes = ['text', 'html'];\n\n    if (validNodeTypes.includes(node.type)) {\n      return every(node.children, child => {\n        return validChildTypes.includes(child.type);\n      });\n    }\n  }\n\n  /**\n   * Return the plugin and RegExp.match result from the first plugin with a\n   * pattern that matches the given text.\n   */\n  function matchTextToPlugin(text) {\n    let match;\n    const plugin = plugins.find(p => {\n      match = text.match(p.pattern);\n      return !!match;\n    });\n    return { plugin, match };\n  }\n\n  /**\n   * A match is only valid if it takes up the entire paragraph.\n   */\n  function validateMatch(text, match) {\n    return match && match[0].length === text.length;\n  }\n\n  /**\n   * Create a new node with shortcode data included. Use an 'html' node instead\n   * of a 'text' node as the child to ensure the node content is not parsed by\n   * Remark or Rehype. Include the child as an array because an MDAST paragraph\n   * node must have it's children in an array.\n   */\n  function createShortcodeNode(text, plugin, match) {\n    const shortcode = plugin.id;\n    const shortcodeData = plugin.fromBlock(match);\n    const data = { shortcode, shortcodeData };\n    const textNode = u('html', text);\n    return u('paragraph', { data }, [textNode]);\n  }\n}\n"],"file":"remarkShortcodes.js"}